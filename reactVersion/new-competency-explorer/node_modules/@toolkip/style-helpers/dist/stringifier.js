"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const object_helpers_1 = require("@toolkip/object-helpers");
const placeholders_1 = require("./placeholders");
const MAX_LENGTH = 10000;
class _StyleStringifier {
    stringify(styles) {
        if (!styles) {
            return [];
        }
        return this._stringify(styles);
    }
    _stringify(styles) {
        let out = [];
        let curStr = "";
        object_helpers_1.map(styles, (cssDeclaration, selector) => {
            let clsStr = this.generateContentForStyle(selector, cssDeclaration);
            if (!clsStr) {
                return;
            }
            if ((curStr.length + clsStr.length) >= MAX_LENGTH) {
                out.push(curStr);
                curStr = clsStr;
            }
            else {
                curStr += clsStr;
            }
        });
        if (curStr) {
            out.push(curStr);
        }
        return out;
    }
    generateContentForStyle(selector, attr) {
        if (attr instanceof Array) {
            return this._generateContentForFontDefinition(selector, attr);
        }
        else {
            return this._generateContentForCssClass(selector, attr);
        }
    }
    _generateContentForCssClass(selector, attr) {
        let styleString = this._buildCssClassContentString(selector, attr);
        if (styleString) {
            styleString = this._formatClass(selector, styleString);
            if (selector.indexOf("{") !== -1) {
                styleString += "\n}";
            }
        }
        return styleString;
    }
    _generateContentForFontDefinition(fontName, srcFiles) {
        let src = [];
        for (let srcFile of srcFiles) {
            src.push(this._formatFontface(srcFile.url, srcFile.format));
        }
        let attr = {
            fontFamily: fontName,
            src: src.join(",")
        };
        return this._generateContentForCssClass("@font-face", attr);
    }
    _buildCssClassContentString(selector, attr) {
        let isGeneratingAnimation = (selector.indexOf("@keyframes") !== -1);
        let styleString = [];
        object_helpers_1.map(attr, (propertyValue, propertyName) => {
            if (isGeneratingAnimation) {
                styleString.push(this._buildAnimationValueString(propertyName, propertyValue));
            }
            else {
                styleString.push(this._formatProperty(propertyName, propertyValue));
            }
        });
        return styleString.join("");
    }
    _buildAnimationValueString(propertyName, propertyValue) {
        let styleString = "";
        object_helpers_1.map(propertyValue, (pValue, pName) => {
            if (!pValue) {
                return;
            }
            styleString += this._formatProperty(pName, pValue);
        });
        if (!styleString) {
            return "";
        }
        return this._formatClass(propertyName, styleString);
    }
    getPropertyName(jsPropName) {
        let prop = jsPropName;
        if (prop.toLowerCase() === prop) {
            return prop;
        }
        const regex = /([A-Z])/g;
        let segments = prop.split(regex);
        for (let idx = 0; idx < segments.length; idx++) {
            segments[idx] = this._getUpdatedSegment(segments[idx], idx === 0);
        }
        return segments.join("");
    }
    _getUpdatedSegment(segment, isFirst) {
        if (isFirst && this._isCssPrefix(segment)) {
            segment = "-" + segment;
        }
        if (segment.toLowerCase() !== segment) {
            segment = "-" + segment.toLowerCase();
        }
        return segment;
    }
    _isCssPrefix(test) {
        switch (test) {
            case "webkit":
            case "moz":
            case "ms":
            case "o":
                return true;
        }
        return false;
    }
    _formatClass(selector, value) {
        return `${selector} {\n${value}}\n`;
    }
    _formatProperty(key, value) {
        let placeholder = placeholders_1.findContainedPlaceholder(value);
        if (placeholder) {
            value = value.replace(`<${placeholder.name}:${placeholder.defaultValue}>`, placeholder.defaultValue);
        }
        return `\t${this.getPropertyName(key)} : ${value};\n`;
    }
    _formatFontface(url, format) {
        return `url(${url}) format(${format})`;
    }
}
const StyleStringifier = new _StyleStringifier();
function stringifyStyles(styles) {
    return StyleStringifier.stringify(styles);
}
exports.stringifyStyles = stringifyStyles;
function stringifyStyle(selector, definition) {
    return StyleStringifier.generateContentForStyle(selector, definition);
}
exports.stringifyStyle = stringifyStyle;
function getCssPropertyName(jsPropName) {
    return StyleStringifier.getPropertyName(jsPropName);
}
exports.getCssPropertyName = getCssPropertyName;
getCssPropertyName("webkitAlignContent");
