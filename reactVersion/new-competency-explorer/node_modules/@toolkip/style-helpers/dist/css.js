"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const primitive_helpers_1 = require("@toolkip/primitive-helpers");
const shared_types_1 = require("@toolkip/shared-types");
const getClassableElement = (elem) => {
    if (shared_types_1.isDrawable(elem)) {
        return elem.base;
    }
    else {
        return elem;
    }
};
function getClass(elem) {
    const e = getClassableElement(elem);
    return e.getAttribute('class') || '';
}
exports.getClass = getClass;
function getClasses(elem) {
    const cls = getClass(elem);
    if (!cls) {
        return [];
    }
    return cls.split(' ');
}
exports.getClasses = getClasses;
function addClass(elem, clsName) {
    if (!elem || !clsName)
        return;
    const e = getClassableElement(elem);
    const cls = e.getAttribute("class");
    if (!cls) {
        e.setAttribute("class", primitive_helpers_1.trim(clsName));
        return;
    }
    const paddedCls = " " + cls + " ";
    if (paddedCls.indexOf(' ' + clsName + ' ') === -1) {
        e.setAttribute("class", primitive_helpers_1.trim(cls + ' ' + clsName));
    }
    return elem;
}
exports.addClass = addClass;
;
function addClasses(elem, ...clsNames) {
    if (!elem ||
        !clsNames ||
        clsNames.length === 0) {
        return;
    }
    const e = getClassableElement(elem);
    const classes = getClasses(elem);
    for (let clsName of clsNames) {
        if (!clsName) {
            continue;
        }
        if (primitive_helpers_1.indexOf(classes, clsName) !== -1) {
            continue;
        }
        classes.push(clsName);
    }
    e.setAttribute('class', classes.join(' '));
    return elem;
}
exports.addClasses = addClasses;
function removeClass(elem, clsName) {
    if (!elem || !clsName)
        return;
    let e;
    if (shared_types_1.isDrawable(elem)) {
        e = elem.base;
    }
    else {
        e = elem;
    }
    let cls = " " + e.getAttribute("class") + " ";
    const len = cls.length;
    cls = cls.replace(" " + clsName + " ", " ");
    if (cls.length !== len) {
        e.setAttribute("class", primitive_helpers_1.trim(cls));
    }
    return elem;
}
exports.removeClass = removeClass;
;
function addOrRemoveClass(elem, clsName, shouldAdd) {
    if (shouldAdd) {
        addClass(elem, clsName);
    }
    else {
        removeClass(elem, clsName);
    }
    return elem;
}
exports.addOrRemoveClass = addOrRemoveClass;
function hasClass(elem, cls) {
    let e;
    let cur_cls;
    if (!elem)
        return;
    if (shared_types_1.isDrawable(elem)) {
        e = elem.base;
    }
    else {
        e = elem;
    }
    cur_cls = " " + e.getAttribute("class") + " ";
    if (cur_cls.indexOf(" " + cls + " ") === -1) {
        return false;
    }
    return true;
}
exports.hasClass = hasClass;
;
function clearClass(elem) {
    if (!elem) {
        return;
    }
    let e;
    if (shared_types_1.isDrawable(elem)) {
        e = elem.base;
    }
    else {
        e = elem;
    }
    e.setAttribute("class", "");
    return elem;
}
exports.clearClass = clearClass;
function toggleClass(elem, clsName) {
    return addOrRemoveClass(elem, clsName, !hasClass(elem, clsName));
}
exports.toggleClass = toggleClass;
function setProperty(cls, item, val, force) {
    let i;
    let css;
    let sIdx;
    let rules;
    let rule;
    for (sIdx = 0; sIdx < document.styleSheets.length; sIdx += 1) {
        css = document.all ? 'rules' : 'cssRules';
        rules = document.styleSheets[sIdx][css];
        if (rules) {
            for (i = 0; i < rules.length; i += 1) {
                rule = rules[i];
                if (rule.selectorText === cls) {
                    if ((rule.style[item]) || (force)) {
                        rule.style[item] = val;
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
exports.setProperty = setProperty;
;
function getProperty(cls, item) {
    let i;
    let css;
    let sIdx;
    let rules;
    let rule;
    for (sIdx = 0; sIdx < document.styleSheets.length; sIdx += 1) {
        css = document.all ? 'rules' : 'cssRules';
        rules = document.styleSheets[sIdx][css];
        if (rules) {
            for (i = 0; i < rules.length; i += 1) {
                rule = rules[i];
                if (rule.selectorText === cls) {
                    return (rule.style[item]);
                }
            }
        }
    }
    return "";
}
exports.getProperty = getProperty;
;
function _old_CreateClass(selector, attr, noAppend) {
    let cls;
    let a;
    let styles;
    styles = document.getElementsByTagName("style");
    if (noAppend || styles.length > 0) {
        cls = styles[0];
    }
    else {
        cls = document.createElement("style");
        cls.innerHTML = "";
    }
    cls.innerHTML += "\n" + selector + " {\n";
    for (a in attr) {
        if (attr.hasOwnProperty(a)) {
            if (attr[a].key) {
                cls.innerHTML += "\t" + attr[a].key + ": " + attr[a].val + ";\n";
            }
            else {
                cls.innerHTML += "\t" + a + " : " + attr[a] + ";\n";
            }
        }
    }
    cls.innerHTML += "\n}";
    if (!noAppend) {
        document.head.appendChild(cls);
    }
    return cls;
}
function getComputedStyle(elem, attr) {
    let style;
    let e;
    if (shared_types_1.isDrawable(elem)) {
        e = elem.base;
    }
    else {
        e = elem;
    }
    if (window.getComputedStyle) {
        style = window.getComputedStyle(e);
        if (attr) {
            return style.getPropertyValue(attr);
        }
        else {
            return style;
        }
    }
    else if (e.currentStyle) {
        style = e.currentStyle;
        if (attr) {
            return style[attr];
        }
        else {
            return style;
        }
    }
    return null;
}
exports.getComputedStyle = getComputedStyle;
