"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_types_1 = require("@toolkip/shared-types");
const style_helpers_1 = require("@toolkip/style-helpers");
const style_libraries_1 = require("@toolkip/style-libraries");
const object_helpers_1 = require("@toolkip/object-helpers");
const _typeGuards_1 = require("./_typeGuards");
const model_1 = require("@toolkip/model");
function _coreCreateElements(objs, keyedElems, recurseVia) {
    if (!shared_types_1.isArray(objs)) {
        return [this._coreCreateElement(objs, keyedElems, recurseVia)];
    }
    else {
        const out = [];
        for (let obj of objs) {
            out.push(this._coreCreateElement(obj, keyedElems, recurseVia));
        }
        return out;
    }
}
exports._coreCreateElements = _coreCreateElements;
function _coreCreateElement(obj, keyedElems, recurseVia) {
    let elem;
    let drawable;
    if (obj.drawable) {
        drawable = _createDrawable(obj.drawable);
        elem = drawable.base;
    }
    else {
        elem = _createStandardElement(obj);
    }
    if (!recurseVia) {
        recurseVia = _coreCreateElement;
    }
    _setElemIdentfiers(elem, obj, keyedElems, drawable);
    _setElemClass(elem, obj);
    _setElemStyles(elem, obj);
    _setElemAttributes(elem, obj);
    _setElemStyle(elem, obj);
    _setEventListeners(elem, obj);
    if (obj.children) {
        _addElemChildren(elem, obj, keyedElems, recurseVia);
    }
    else {
        _setElemBaseContent(elem, obj);
    }
    _setElemSelector(obj, elem);
    _appendElemToParent(obj, elem);
    return elem;
}
exports._coreCreateElement = _coreCreateElement;
function _createDrawable(ctor) {
    let child;
    try {
        child = ctor();
    }
    catch (e) {
        child = new ctor();
    }
    return child;
}
function _createStandardElement(obj) {
    let elem;
    let type = obj.type || "div";
    if (obj.namespace) {
        elem = document.createElementNS(obj.namespace, type);
    }
    else {
        elem = document.createElement(type);
    }
    return elem;
}
function _setElemIdentfiers(elem, obj, keyedElems, drawable) {
    if (obj.id) {
        _handleSelector(obj.id, (id) => elem.setAttribute("id", id));
    }
    if (obj.key && keyedElems) {
        if (drawable) {
            keyedElems[obj.key] = drawable;
        }
        else {
            keyedElems[obj.key] = elem;
        }
    }
}
function _setElemClass(elem, obj) {
    const cls = obj.cls;
    if (!cls) {
        return;
    }
    _handleSelector(cls, (v) => _innerSetElemClass(elem, v, obj));
}
function _innerSetElemClass(elem, cls, obj) {
    if (_typeGuards_1.isClassDefinition(cls)) {
        _setElemStyles(elem, { styles: cls.styles });
        _setElemClassName(elem, cls.name);
    }
    else {
        _setElemClassName(elem, cls);
    }
}
function _setElemClassName(elem, name) {
    style_helpers_1.clearClass(elem);
    if (shared_types_1.isString(name)) {
        style_helpers_1.addClass(elem, name);
    }
    else if (shared_types_1.isArray(name)) {
        style_helpers_1.addClass(elem, name.join(" "));
    }
    ;
}
function _setElemStyles(elem, obj) {
    const styles = obj.styles;
    if (!styles) {
        return;
    }
    let styleArray;
    if (shared_types_1.isArray(styles)) {
        styleArray = [...styles];
    }
    else {
        styleArray = [styles];
    }
    for (let s of styleArray) {
        _handleSelector(s, (v) => _innerSetElemStyles(elem, v));
    }
}
function _innerSetElemStyles(elem, styles) {
    const flattenedStyles = style_helpers_1.flattenStyles(styles);
    object_helpers_1.map(flattenedStyles, (value, selector) => {
        style_libraries_1.createCssClass(selector, value, 'create_elements');
    });
}
function _setElemAttributes(elem, obj) {
    if (!obj.attr) {
        obj.attr = {};
    }
    if (_isFocusable(obj)) {
        obj.focusable = true;
    }
    if (_needsTabIndex(obj)) {
        obj.attr.tabindex = 0;
    }
    object_helpers_1.map(obj.attr, (value, key) => {
        _handleSelector(value, (v) => _innerSetAttribute(elem, v, key));
    });
}
function _innerSetAttribute(elem, value, key) {
    if (shared_types_1.isNullOrUndefined(value)) {
        return;
    }
    if (value.key) {
        let pair = value;
        _setElemAttribute(elem, pair.key, pair.val);
    }
    else {
        _setElemAttribute(elem, key, value);
    }
}
function _setElemAttribute(elem, key, value) {
    switch (key) {
        case "value":
            elem.value = value;
            break;
        default:
            elem.setAttribute(key, value);
            break;
    }
}
function _isFocusable(obj) {
    if (!shared_types_1.isNullOrUndefined(obj.focusable)) {
        return obj.focusable;
    }
    if (!obj.eventListeners) {
        return false;
    }
    if (!obj.eventListeners.click) {
        return false;
    }
    return true;
}
function _needsTabIndex(obj) {
    if (!_isFocusable(obj)) {
        return false;
    }
    if (obj.attr.tabIndex) {
        return false;
    }
    return true;
}
function _setElemStyle(elem, obj) {
    if (!obj.style) {
        return;
    }
    _handleSelector(obj.style, (style) => {
        object_helpers_1.map(style, (val, key) => {
            elem.style[key] = val;
        });
    });
}
function _setEventListeners(elem, obj) {
    if (!obj.eventListeners) {
        return;
    }
    if (obj.focusable && obj.eventListeners.click && !obj.eventListeners.keypress) {
        let clickFunc = obj.eventListeners.click;
        obj.eventListeners.keypress = (e) => {
            if (e.keyCode !== 13 && e.keyCode !== 32) {
                return;
            }
            clickFunc(e);
            e.preventDefault();
        };
        let preventFocus = false;
        obj.eventListeners.mousedown = (e) => {
            preventFocus = true;
            elem.blur();
        };
        obj.eventListeners.mouseup = (e) => {
            preventFocus = false;
        };
        obj.eventListeners.focus = (e) => {
            if (preventFocus) {
                e.preventDefault();
                elem.blur();
                return false;
            }
        };
    }
    object_helpers_1.map(obj.eventListeners, (listener, key) => {
        elem.addEventListener(key, listener);
    });
}
function _setElemBaseContent(elem, obj) {
    if (obj.content) {
        _handleSelector(obj.content, (innerHTML) => elem.innerHTML = innerHTML);
    }
    else if (obj.innerHTML) {
        _handleSelector(obj.innerHTML, (innerHTML) => elem.innerHTML = innerHTML);
    }
    else if (obj.innerText) {
        _handleSelector(obj.innerText, (innerText) => elem.innerText = innerText);
    }
}
function _addElemChildren(elem, obj, keyedElems, recurseVia) {
    if (!obj.children) {
        return;
    }
    _handleSelector(obj.children, (v) => {
        elem.innerHTML = "";
        _innerAddElemChildren(elem, v, obj.namespace, keyedElems, recurseVia);
    });
}
function _innerAddElemChildren(elem, children, namespace, keyedElems, recurseVia) {
    for (let c of children) {
        if (!c) {
            console.warn("cannot append non-existent child element");
            continue;
        }
        _handleSelector(c, (v) => {
            _innerAddElemChild(elem, v, namespace, keyedElems, recurseVia);
        });
    }
}
function _innerAddElemChild(elem, child, namespace, keyedElems, recurseVia) {
    if (shared_types_1.isArray(child)) {
        _innerAddElemChildren(elem, child, namespace, keyedElems, recurseVia);
    }
    else if (shared_types_1.isDrawable(child)) {
        child.draw(elem);
    }
    else if (child.setAttribute) {
        elem.appendChild(child);
    }
    else {
        let def = child;
        if (namespace) {
            def.namespace = namespace;
        }
        let c = recurseVia(def, keyedElems);
        elem.appendChild(c);
    }
}
function _appendElemToParent(obj, elem) {
    if (!obj.parent) {
        return;
    }
    if (shared_types_1.isDrawable(elem)) {
        elem.draw(obj.parent);
    }
    else {
        obj.parent.appendChild(elem);
    }
}
const _setElemSelector = (obj, elem) => {
    if (!obj.selector) {
        return;
    }
    const { selector, applyCb } = obj.selector;
    selector.apply((payload) => { applyCb(payload, elem); });
    const value = selector.getData();
    applyCb({ value, eventType: 'none' }, elem);
};
const _handleSelector = (value, cb) => {
    if (model_1.isSelector(value)) {
        value.apply((payload) => {
            const { value } = payload;
            cb(value, payload);
        });
    }
    else {
        cb(value, {});
    }
};
