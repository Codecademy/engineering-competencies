"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _library_1 = require("./_library");
const object_helpers_1 = require("@toolkip/object-helpers");
const style_helpers_1 = require("@toolkip/style-helpers");
const html_helpers_1 = require("@toolkip/html-helpers");
class _PlaceholderLibrary extends _library_1._Library {
    constructor() {
        super(...arguments);
        this._indexedPlaceholders = {};
    }
    get _idSuffix() { return "placeholder"; }
    _indexByPlaceholder(styles, uniqueKey) {
        let d = { [uniqueKey]: styles };
        let out = style_helpers_1.indexByPlaceholder(d);
        object_helpers_1.map(out, (dict, placeholder) => {
            if (!dict[uniqueKey]) {
                return;
            }
            let placeholderIdx = this._indexedPlaceholders[placeholder] || {};
            let uniqueIdx = placeholderIdx[uniqueKey] || {};
            let combo = object_helpers_1.combineObjects(uniqueIdx, dict[uniqueKey]);
            object_helpers_1.setDictValue(this._indexedPlaceholders, combo, [placeholder, uniqueKey]);
        });
        return out;
    }
    _updateElems(styles, uniqueKey) {
        let indexed = this._indexByPlaceholder(styles, uniqueKey);
        object_helpers_1.map(indexed, (dict, placeholder) => {
            let idx = dict[uniqueKey];
            let builtStyles = style_helpers_1.mapIndexToStyle(idx, this._rawStyles[uniqueKey]);
            if (!builtStyles) {
                return;
            }
            this._updatePlaceholderElem(builtStyles, uniqueKey, placeholder);
        });
    }
    _updatePlaceholderElem(styles, uniqueKey, placeholder) {
        super._updateElems(styles, this._formatElemString(uniqueKey, placeholder));
    }
    replacePlaceholder(opts) {
        if (opts.baseElem) {
            this._replaceSingleElemPlaceholders(opts);
        }
        else if (opts.uniqueKey) {
            this._replacePlaceholderForKey(opts);
        }
        else {
            this._replacePlaceholdersForMultipleKeys(opts);
        }
    }
    _replacePlaceholdersForMultipleKeys(opts) {
        const idx = this._indexedPlaceholders[opts.placeholder];
        if (!idx || object_helpers_1.isEmptyObject(idx)) {
            return;
        }
        object_helpers_1.map(idx, (_, uniqueKey) => {
            opts.uniqueKey = uniqueKey;
            this._replacePlaceholderForKey(opts);
            opts.uniqueKey = null;
        });
    }
    _replacePlaceholderForKey(opts) {
        if (!opts.uniqueKey) {
            return;
        }
        const replacedStyles = this._replacePlaceholderViaIndex(opts);
        this._updatePlaceholderElem(replacedStyles, opts.uniqueKey, opts.placeholder);
    }
    _replaceSingleElemPlaceholders(opts) {
        if (!opts.uniqueKey || !opts.newValue) {
            return;
        }
        const replacedStyles = this._replacePlaceholderViaIndex(opts);
        const matches = this._findMatches(opts.baseElem, object_helpers_1.getKeys(replacedStyles));
        object_helpers_1.map(matches, (matchedElems, selector) => {
            for (let matchedElem of matchedElems) {
                object_helpers_1.map(replacedStyles[selector], (pVal, pName) => {
                    matchedElem.style[pName] = pVal;
                });
            }
        });
    }
    _findMatches(parent, selectors) {
        let out = {};
        for (let s of selectors) {
            out[s] = this._findMatch(parent, s);
        }
        return out;
    }
    _findMatch(parent, selector) {
        let out = [];
        let nodeQueue = [parent];
        let cnt = 0;
        while (cnt < nodeQueue.length) {
            let currentNode = nodeQueue[cnt];
            if (html_helpers_1.doesElementMatchSelector(currentNode, selector)) {
                out.push(currentNode);
            }
            nodeQueue = nodeQueue.concat([...currentNode.childNodes]);
            cnt += 1;
        }
        return out;
    }
    _replacePlaceholderViaIndex(opts) {
        if (!this._indexedPlaceholders[opts.placeholder]) {
            this._indexedPlaceholders[opts.placeholder] = {};
        }
        const styles = this._indexedPlaceholders[opts.placeholder][opts.uniqueKey] || {};
        let mappedStyles = style_helpers_1.mapIndexToStyle(styles, this._rawStyles[opts.uniqueKey]);
        return style_helpers_1.replacePlaceholders(mappedStyles, opts.placeholder, opts.newValue);
    }
    _formatElemString(uniqueKey, placeholder) {
        return `${uniqueKey}-${placeholder}`;
    }
}
exports.PlaceholderLibrary = new _PlaceholderLibrary();
