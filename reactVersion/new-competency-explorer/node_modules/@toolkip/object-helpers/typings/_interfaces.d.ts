export interface IKeyValPair<T> {
    key?: string;
    val?: T;
}
export declare type IMappedType<T> = {
    [K in keyof T]?: T[K];
};
export declare type ISelectOptions = INumericSelectOptions | IStringSelectOptions;
export interface INumericSelectOptions {
    [value: number]: string;
}
export interface IStringSelectOptions {
    [value: string]: string;
}
export interface IConstructor<T> {
    new (...addlArgs: any[]): T;
}
export interface IToggleBtnOption<T> {
    label: string;
    value: T;
    imageURL?: string;
}
export declare type IDictionary<T, K extends string | number = string | number> = Record<K, T>;
export declare type INumericDictionary<T, K extends number = number> = {
    [key in K]: T;
};
export interface IMapFunction<T, R> {
    (elem: T, key: string | number | keyof any, src: Mappable<T>): R;
}
export declare type Mappable<T = any> = T[] | Record<string | number | symbol, T>;
export interface IShouldInclude<T = any> {
    (value: T, key: string | number | keyof any, src: Mappable<T>): boolean;
}
export interface IQuitConditionFunction {
    (): boolean;
}
export declare type Key = string | number | symbol;
export interface ICustomCloner<T> {
    typeGuard: <T>(data: T, key?: Key) => boolean;
    cloner: <T>(data: T, key?: Key) => T;
}
export interface ICloneable<T> {
    clone(...addlParams: any[]): T;
}
