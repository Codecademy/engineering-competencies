"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_types_1 = require("@toolkip/shared-types");
function map(toMap, callback, shouldQuit) {
    let out = [];
    if (!toMap) {
        return out;
    }
    if (shared_types_1.isArray(toMap)) {
        let done;
        toMap.map((value, key, arr) => {
            if (done) {
                return;
            }
            let result = callback ? callback(value, key, arr) : value;
            out.push(result);
            if (!shouldQuit) {
                return;
            }
            if (shouldQuit()) {
                done = true;
            }
        });
    }
    else {
        let cnt = 0;
        let key;
        for (key in toMap) {
            if (toMap.hasOwnProperty(key)) {
                let result = callback ? callback(toMap[key], key, toMap) : toMap[key];
                if (result) {
                    out.push(result);
                }
                cnt += 1;
                if (!shouldQuit) {
                    continue;
                }
                if (shouldQuit()) {
                    break;
                }
            }
        }
    }
    return out;
}
exports.map = map;
function filter(toFilter, shouldInclude) {
    const out = [];
    map(toFilter, (elem, key, src) => {
        if (shouldInclude(elem, key, src)) {
            out.push(elem);
        }
    });
    return out;
}
exports.filter = filter;
function getNextKey(object, lastKey) {
    let propName;
    let nextKey = (!lastKey);
    for (propName in object) {
        if (object.hasOwnProperty(propName)) {
            if (nextKey) {
                return propName;
            }
            else if (propName === lastKey) {
                nextKey = true;
            }
        }
    }
    return "";
}
exports.getNextKey = getNextKey;
function getKeys(object) {
    let keys = Object.keys(object) || [];
    for (let i = keys.length - 1; i >= 0; i -= 1) {
        let key = keys[i];
        if (!object.hasOwnProperty(key)) {
            keys.splice(i, 1);
        }
    }
    return keys;
}
exports.getKeys = getKeys;
function keyCount(object) {
    return getKeys(object).length;
}
exports.keyCount = keyCount;
function setDictValue(object, val, keys) {
    if (!object) {
        object = {};
    }
    let curObj = object;
    for (let i = 0; i < keys.length; i += 1) {
        let k = keys[i];
        let initVal = {};
        if (i === (keys.length - 1)) {
            initVal = val;
        }
        if (!curObj[k]) {
            curObj[k] = initVal;
        }
        curObj = curObj[k];
    }
    return object;
}
exports.setDictValue = setDictValue;
function getPrototype(obj) {
    if (obj.prototype) {
        return obj.prototype;
    }
    if (obj.__proto__) {
        return obj.__proto__;
    }
    return null;
}
exports.getPrototype = getPrototype;
