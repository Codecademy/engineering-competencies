import { ICodeEventCallback, ICodeEventStandardContent } from "@toolkip/code-event";
import { ICloneable } from '@toolkip/object-helpers';
import { IEquatable } from '@toolkip/comparable';
export interface IModelData {
    [key: string]: any;
}
export declare type ModelType = 'primitive' | 'keyed' | 'array';
export interface IBasicModel<T> extends ICloneable<IModel<T>>, IEquatable {
    setData(data: T): void;
    getData(): T;
    addEventListener(cb: ModelEventCallback<"_" | any, T | any>): void;
    import(data: T): void;
    export(): T;
    getType(): ModelType;
}
export interface IKeyedModel<T, K, X> extends IBasicModel<T>, IEquatable {
    import(data: Partial<T>): void;
    set(key: K, value: X): void;
    update(key: K, value: Partial<X>): void;
    get(key: K): X;
    getModel(key: K): IModel<X>;
    clone(tx?: IKeyedModelTransforms<T, X>): IKeyedModel<T, K, X>;
    addEventListener(cb: ModelEventCallback<"_" | K, T | X>): void;
}
export interface IArrayModel<X, K, T = X[]> {
    add(value: X): void;
    remove(key: K): X;
    clear(): void;
}
export declare type IModel<T, K = any, X = any> = IBasicModel<T> | IKeyedModel<T, K, X> | (IKeyedModel<T, K, X> & IArrayModel<X, K, T>);
export declare type IModelTransformFunc<X> = (value: X) => X;
export declare type IModelTransform<X> = {
    incoming?: IModelTransformFunc<X>;
    outgoing?: IModelTransformFunc<X>;
};
export interface IModelTransforms<T> {
    "_"?: IModelTransform<T>;
}
export declare type IObjectKeyedModelTransforms<T> = IModelTransforms<T> & {
    [K in keyof T]?: IModelTransform<T[K]>;
};
export declare type IStringKeyedModelTransforms<T, X> = IModelTransforms<T> & {
    [k: string]: IModelTransform<X>;
};
export declare type INumericKeyedModelTransforms<T, X> = IModelTransforms<T> & {
    [k: number]: IModelTransform<X>;
};
export declare type IKeyedModelTransforms<T, X = any> = IObjectKeyedModelTransforms<T> | IStringKeyedModelTransforms<T, X> | INumericKeyedModelTransforms<T, X>;
export declare type IArrayedModelTransforms<X> = INumericKeyedModelTransforms<X[], X> & {
    "*": IModelTransform<X>;
};
export declare type ModelEventType = 'add' | 'remove' | 'modify' | 'none';
export declare type ModelEventPayload<K, X> = {
    value: X;
    oldValue?: X;
    key?: K;
    eventType?: ModelEventType;
    eventChain?: ModelEventFullPayload<any, any>;
};
export declare type ModelEventFullPayload<K, X, T = any> = ICodeEventStandardContent<Selectable<T>> & ModelEventPayload<K, X>;
export declare type ModelEventCallback<K, X> = ICodeEventCallback<ModelEventPayload<K, X>>;
export interface ISelector<I, O, X = any, K = any> {
    apply: (applyFunc: SelectorApplyFunc<O>) => void;
    map: (mapFunc: SelectorMapFunc<X, K>) => void;
    select: (selectFunc: SelectorFunc<O, any>, filters?: SelectorFilters<O>) => ISelector<O, any, any, any>;
    addEventListener: (cb: SelectorApplyFunc<O>) => void;
    getData: () => O;
}
export declare type SelectorFilters<I> = {
    keys?: SelectKey<I>[];
    eventTypes?: ModelEventType[];
};
export declare type SelectorFilterMaps<I> = {
    keys: Map<SelectKey<I>, boolean>;
    eventTypes: Map<ModelEventType, boolean>;
    customFilters: SelectorFilterFunc<I>[];
};
export declare type SelectKey<I> = string | number | keyof I;
export declare type SelectorFunc<I, O> = (model: I, payload?: ModelEventFullPayload<any, any>) => O;
export declare type SelectorApplyFunc<O> = (payload: ModelEventFullPayload<any, O>) => void;
export declare type SelectorMapFunc<X, K> = (elem: X, key?: K, payload?: ModelEventFullPayload<any, any>) => void;
export declare type SelectorMapSelectFunc<X, K, O = any> = (elem: X, key?: K, payload?: ModelEventFullPayload<any, any>) => O;
export declare type SelectorFilterFunc<X> = (payload: ModelEventFullPayload<any, X>) => boolean;
export declare type Selectable<I> = IModel<I> | ISelector<any, I>;
