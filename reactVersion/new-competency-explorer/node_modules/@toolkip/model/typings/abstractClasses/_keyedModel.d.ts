import { _Model } from './_model';
import { IKeyedModelTransforms, ModelEventCallback, ModelEventPayload, IModel, IKeyedModel, ModelType, IArrayModel, IBasicModel } from '../_shared';
export declare abstract class _KeyedModel<T, K, X> extends _Model<T> {
    constructor(data?: Partial<T>, transforms?: IKeyedModelTransforms<T, X>);
    getType(): ModelType;
    addKeyedListener(key: K, cbFunc: ModelEventCallback<K, X>): void;
    protected _transforms: IKeyedModelTransforms<T, X>;
    protected _getApplicableTransforms(key?: K): any;
    protected abstract _getValue(output: T, key: K): X | IModel<X>;
    protected abstract _setValue(output: T, key: K, value: X | IModel<X>): void;
    protected abstract _map(data: T, mapFunc: (val: X | IModel<X>, key: K) => void): any;
    get(key: K): X;
    protected _innerGet(key: K): X;
    protected _innerGetData(): T;
    getModel(key: K, type: 'b'): IBasicModel<X>;
    getModel(key: K, type?: 'o'): IKeyedModel<X, any, any>;
    getModel(key: K, type: 'a'): IArrayModel<any, any, X> & IKeyedModel<X, any, any>;
    update(key: K, newValue: Partial<X>): void;
    set(key: K, value: X): void;
    protected _innerSet(payload: Partial<ModelEventPayload<K, X>>): IKeyedModel<X, any, any>;
    protected _innerSetData(payload: any): void;
    protected _innerImport(data: T): T;
    protected _innerExport(): T;
}
