"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const modelManager_1 = require("../modelManager");
const modelFactory_1 = require("../../helpers/modelFactory");
modelFactory_1.setupModelWrapping();
const identifiables = [
    { id: '1', name: 'A' },
    { id: '2', name: 'B' }
];
describe('ModelManager', () => {
    it('sets appropriate default values', () => {
        const model = new modelManager_1.MManager();
        expect(model.toArray()).toMatchObject([]);
    });
    it('sets values when passed into the constructor', () => {
        const model = new modelManager_1.MManager(identifiables);
        expect(model.getData()).toMatchObject(identifiables);
        expect(model.get('1')).toMatchObject(identifiables[0]);
    });
    it('sets over existing values', () => {
        const model = new modelManager_1.MManager(identifiables);
        const data = Object.assign(Object.assign({}, identifiables[0]), { name: 'Z' });
        model.set(identifiables[0].id, data);
        expect(model.get(identifiables[0].id)).toMatchObject(data);
    });
    it('clears appropriately', () => {
        expect.assertions(4);
        const model = new modelManager_1.MManager(identifiables);
        model.addEventListener((payload) => {
            expect(payload.eventType).toEqual('remove');
            expect(payload.oldValue).toHaveLength(2);
        });
        model.clear();
        expect(model.toArray()).toMatchObject([]);
        expect(model.toArray()).toHaveLength(0);
    });
    it('handles events on keys', () => {
        expect.assertions(4);
        const model = new modelManager_1.MManager(identifiables);
        model.addKeyedListener(identifiables[0].id, (payload) => {
            expect(payload.eventType).toEqual('modify');
            expect(payload.oldValue.name).toEqual('A');
            expect(payload.value.name).toEqual('Z');
        });
        model.set(identifiables[0].id, Object.assign(Object.assign({}, identifiables[0]), { name: 'Z' }));
        expect(model.get(identifiables[0].id)).toEqual(Object.assign(Object.assign({}, identifiables[0]), { name: 'Z' }));
    });
    it('handles grabbing nested models and setting directly', () => {
        expect.assertions(5);
        const model = new modelManager_1.MManager(identifiables);
        const cb = jest.fn((payload) => {
            expect(payload.eventType).toEqual('modify');
            expect(payload.oldValue.name).toEqual('A');
            expect(payload.value.name).toEqual('Z');
        });
        model.addKeyedListener(identifiables[0].id, cb);
        const nestedModel = model.getModel(identifiables[0].id);
        nestedModel.set('name', 'Z');
        expect(model.get(identifiables[0].id)).toEqual(Object.assign(Object.assign({}, identifiables[0]), { name: 'Z' }));
        expect(cb).toHaveBeenCalledTimes(1);
    });
    it('can set multiple times from the same nested object', () => {
        expect.assertions(5);
        const model = new modelManager_1.MManager(identifiables);
        const cb = jest.fn((payload) => {
            expect(payload.eventType).toEqual('modify');
        });
        model.addEventListener(cb);
        const id = identifiables[0].id;
        const nestedModel = model.getModel(id);
        nestedModel.set('name', 'Z');
        expect(model.get(id)).toEqual(Object.assign(Object.assign({}, identifiables[0]), { name: 'Z' }));
        nestedModel.set('name', 'Y');
        expect(model.get(id)).toEqual(Object.assign(Object.assign({}, identifiables[0]), { name: 'Y' }));
        expect(cb).toHaveBeenCalledTimes(2);
    });
    it('handles adding', () => {
        expect.assertions(3);
        const model = new modelManager_1.MManager();
        model.addEventListener((payload) => {
            expect(payload.eventType).toEqual('add');
        });
        model.add(identifiables[0]);
        model.add(identifiables[1]);
        expect(model.toArray()).toMatchObject(identifiables);
    });
    it('handles removing', () => {
        expect.assertions(3);
        const model = new modelManager_1.MManager(identifiables);
        model.addEventListener((payload) => {
            expect(payload.eventType).toEqual('remove');
        });
        model.remove(identifiables[0].id);
        model.remove(identifiables[1].id);
        expect(model.toArray()).toMatchObject([]);
    });
});
