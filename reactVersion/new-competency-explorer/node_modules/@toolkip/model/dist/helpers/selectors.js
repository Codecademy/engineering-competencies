"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const object_helpers_1 = require("@toolkip/object-helpers");
const comparable_1 = require("@toolkip/comparable");
const primitiveModels_1 = require("../primitiveModels");
class Selector {
    constructor(model, processor, filters) {
        this._applyFuncs = [];
        this._mapFuncs = [];
        this._processor = processor || ((data) => { return data; });
        this._lastModel = this._processor(model.getData(), {});
        this._setupFilters(filters || {});
        this._addEventListener(model);
    }
    getData() { return this._lastModel; }
    _setupFilters({ keys = [], eventTypes = [] }) {
        this._filterMap = {
            keys: object_helpers_1.arrayToMap(keys),
            eventTypes: object_helpers_1.arrayToMap(eventTypes),
            customFilters: []
        };
    }
    filter(filterFunc) {
        this._filterMap.customFilters.push(filterFunc);
        return this;
    }
    reselect(callbacks) {
        const event = this._createReselectEvent();
        if (!callbacks) {
            this._notifyCallbacks(event);
        }
        else {
            const { apply, map } = callbacks;
            if (apply) {
                this._notifyApplySelectors(event, apply);
            }
            if (map) {
                this._notifyMapSelectors(event, map);
            }
        }
    }
    _createReselectEvent() {
        return {
            name: 'modelchange',
            target: this,
            oldValue: this._lastModel,
            value: this._lastModel,
            eventType: 'none'
        };
    }
    _addEventListener(model) {
        model.addEventListener((payload) => {
            if (this._isFiltered(payload)) {
                return;
            }
            const processedData = this._processor(payload.target.getData(), payload);
            if (comparable_1.equals(processedData, this._lastModel)) {
                return;
            }
            const oldValue = this._lastModel;
            this._lastModel = processedData;
            this._notifyCallbacks(Object.assign(Object.assign({}, payload), { target: this, oldValue, value: processedData, eventChain: payload }));
        });
    }
    _isFiltered(payload) {
        const { key, eventType } = payload;
        const { keys, eventTypes, customFilters } = this._filterMap;
        if (keys.size > 0 && !keys.has(key)) {
            return true;
        }
        if (eventTypes.size > 0 && !eventTypes.has(eventType)) {
            return true;
        }
        for (let cf of customFilters) {
            if (cf(payload)) {
                return true;
            }
        }
        return false;
    }
    _notifyCallbacks(payload) {
        this._notifyApplySelectors(payload, this._applyFuncs);
        this._notifyMapSelectors(payload, this._mapFuncs);
    }
    _notifyApplySelectors(payload, cbs) {
        for (let cb of cbs) {
            cb(payload);
        }
    }
    _notifyMapSelectors(payload, cbs) {
        const { value } = payload;
        if (!object_helpers_1.isMappable(value)) {
            return;
        }
        for (let cb of cbs) {
            object_helpers_1.map(value, (v, k) => {
                cb(v, k, payload);
            });
        }
    }
    apply(cb, skipInitialNotify) {
        this._applyFuncs.push(cb);
        if (!skipInitialNotify) {
            this.reselect({ apply: [cb] });
        }
        return this;
    }
    addEventListener(cb, skipInitialNotify) {
        return this.apply(cb, skipInitialNotify);
    }
    map(cb, skipInitialNotify) {
        this._mapFuncs.push(cb);
        if (!skipInitialNotify) {
            this.reselect({ map: [cb] });
        }
        return this;
    }
    mapSelect(cb, filters) {
        return new Selector(this, (data, payload) => {
            const out = [];
            if (object_helpers_1.isMappable(data)) {
                object_helpers_1.map(data, (e, k) => {
                    out.push(cb(e, k, payload));
                });
            }
            return out;
        }, filters);
    }
    select(processor, filters) {
        return new Selector(this, processor, filters);
    }
}
exports.Selector = Selector;
exports.select = (listenable, processor, filters) => {
    return new Selector(listenable, processor, filters);
};
exports.rawSelect = (rawData, processor, filters) => {
    const model = new primitiveModels_1.Model(rawData);
    return new Selector(model, processor, filters);
};
