"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const comparable_1 = require("@toolkip/comparable");
const object_helpers_1 = require("@toolkip/object-helpers");
const history_1 = require("@toolkip/history");
const _shared_1 = require("../_shared");
const core_1 = require("../_typeguards/core");
const shared_types_1 = require("@toolkip/shared-types");
class _Model {
    constructor(data, transforms) {
        this._innerModel = this._getDefaultValues();
        this.__history = new history_1.HistoryChain();
        this._event = new _shared_1.ModelEvent('modelchange');
        if (transforms) {
            this._transforms = transforms;
        }
        else {
            this._transforms = {};
        }
        if (!shared_types_1.isNullOrUndefined(data)) {
            this.import(data);
        }
    }
    getType() { return 'primitive'; }
    addEventListener(cbFunc) {
        this._event.addEventListener(cbFunc);
    }
    static addEventListener(cbFunc) {
        this._event.addEventListener(cbFunc);
    }
    _dispatchEvent(payload) {
        this._event.dispatch(this, payload);
        _Model._event.dispatch(this, payload);
    }
    _copyEvent(modelToCopyFrom, modelToCopyTo) {
        modelToCopyTo._event = modelToCopyFrom._event;
    }
    _notifyListeners(payload) {
        const { oldValue, value: newValue, eventChain } = payload;
        if (comparable_1.equals(oldValue, newValue)) {
            return;
        }
        if (!payload.eventType) {
            payload.eventType = this._calculateChangeType(oldValue, newValue, eventChain);
        }
        this._dispatchEvent(payload);
    }
    _calculateChangeType(oldVal, newVal, eventChain) {
        if (eventChain) {
            return eventChain.eventType;
        }
        if (newVal && !oldVal) {
            return 'add';
        }
        if (oldVal && !newVal) {
            return 'remove';
        }
        return 'modify';
    }
    _getApplicableTransforms() {
        return this._transforms["_"];
    }
    _updateHistory() {
        this.__history.push(this.getData());
    }
    undo() {
        this.__history.navigateBack((lastState) => {
            if (!lastState) {
                return;
            }
            this.import(lastState);
            return;
        });
    }
    redo() {
        this.__history.navigateForward((nextState) => {
            if (!nextState) {
                return;
            }
            this.import(nextState);
            return;
        });
    }
    getData() {
        return this._innerGetData();
    }
    _innerGetData() {
        return this._cloneData(this._innerModel);
    }
    setData(newData) {
        this._innerSetData({ value: newData });
    }
    _innerSetData(payload) {
        const oldValue = this.getData();
        const { value: newData } = payload;
        const clonedData = this._cloneData(newData);
        this._innerModel = clonedData;
        this._sendUpdate(Object.assign(Object.assign({}, payload), { oldValue, value: this.getData() }));
    }
    _sendUpdate(payload) {
        this._updateHistory();
        this._notifyListeners(payload);
    }
    import(data) {
        var _a;
        const transform = (_a = this._getApplicableTransforms()) === null || _a === void 0 ? void 0 : _a.incoming;
        let importedData;
        if (transform) {
            importedData = transform(data);
        }
        else {
            importedData = this._innerImport(data);
        }
        this.setData(importedData);
    }
    ;
    _innerImport(data) {
        return data;
    }
    export() {
        var _a;
        const transform = (_a = this._getApplicableTransforms()) === null || _a === void 0 ? void 0 : _a.outgoing;
        if (transform) {
            return transform(this.getData());
        }
        else {
            return this._innerExport();
        }
    }
    _innerExport() {
        return this.getData();
    }
    equals(otherModel) {
        if (!core_1.isModel(otherModel)) {
            return false;
        }
        return comparable_1.equals(otherModel.getData(), this.getData());
    }
    clone(tx) {
        const transforms = tx || this._transforms;
        const Ctor = this.constructor;
        const newModel = new Ctor(this.getData(), transforms);
        newModel._event = this._event;
        return newModel;
    }
    _cloneData(data) {
        return object_helpers_1.clone(data);
    }
    _wrapInModel(dataToWrap, key) {
        const newModel = _Model.createModel(dataToWrap);
        if (!core_1.isModel(dataToWrap)) {
            let oldValue = newModel.getData();
            newModel.addEventListener((payload) => {
                if (shared_types_1.isNullOrUndefined(key)) {
                    return;
                }
                const { target, eventType } = payload;
                const value = core_1.isModel(target) ? target.getData() : target;
                this._sendUpdate({
                    eventType,
                    key,
                    oldValue,
                    value,
                    eventChain: payload
                });
                oldValue = value;
            });
        }
        return newModel;
    }
}
exports._Model = _Model;
_Model._event = new _shared_1.ModelEvent('modelchange');
