"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _model_1 = require("./_model");
const core_1 = require("../_typeguards/core");
const shared_types_1 = require("@toolkip/shared-types");
class _KeyedModel extends _model_1._Model {
    constructor(data, transforms) {
        super(data, transforms);
    }
    getType() { return 'keyed'; }
    addKeyedListener(key, cbFunc) {
        this._event.addEventListener((payload) => {
            if (payload.key !== key) {
                return;
            }
            cbFunc(payload);
        }, this);
    }
    _getApplicableTransforms(key) {
        if (!key) {
            return super._getApplicableTransforms();
        }
        return this._transforms[key];
    }
    get(key) {
        return this._innerGet(key);
    }
    _innerGet(key) {
        const model = this._getValue(this._innerModel, key);
        return core_1.isModel(model) ? model.getData() : undefined;
    }
    _innerGetData() {
        if (shared_types_1.isNullOrUndefined(this._innerModel)) {
            return this._innerModel;
        }
        const out = this._getDefaultValues();
        this._map(this._innerModel, (val, key) => {
            if (!core_1.isModel(val)) {
                return;
            }
            this._setValue(out, key, val.getData());
        });
        return out;
    }
    getModel(key) {
        const m = this._getValue(this._innerModel, key);
        if (!core_1.isModel(m)) {
            return null;
        }
        switch (m.getType()) {
            case 'array': return m;
            case 'keyed': return m;
            case 'primitive': return m;
        }
    }
    update(key, newValue) {
        const value = Object.assign(Object.assign({}, this.get(key)), newValue);
        this._innerSet({ key, value });
    }
    set(key, value) {
        this._innerSet({ key, value });
    }
    _innerSet(payload) {
        const { value, key } = payload;
        const oldModel = this.getModel(key);
        if (core_1.isModel(oldModel)) {
            oldModel.setData(value);
            this._setValue(this._innerModel, key, oldModel);
        }
        else {
            const oldValue = payload.oldValue || this.get(key);
            const newModel = this._wrapInModel(value, key);
            this._setValue(this._innerModel, key, newModel);
            this._sendUpdate(Object.assign(Object.assign({}, payload), { oldValue, value: newModel.getData() }));
        }
        return this.getModel(key);
    }
    _innerSetData(payload) {
        const { value } = payload;
        if (core_1.isModel(value)) {
            super._innerSetData(Object.assign(Object.assign({}, payload), { value: this._wrapInModel(value) }));
        }
        else if (shared_types_1.isNullOrUndefined(value)) {
            super._innerSetData(payload);
        }
        else {
            const modelValue = this._getDefaultValues();
            this._map(value, (val, key) => {
                let updatedVal = this._wrapInModel(val, key);
                this._setValue(modelValue, key, updatedVal);
            });
            super._innerSetData(Object.assign(Object.assign({}, payload), { value: modelValue }));
        }
    }
    _innerImport(data) {
        const out = this._getDefaultValues();
        this._map(data, (val, key) => {
            var _a;
            let updatedValue = val;
            const transform = (_a = this._getApplicableTransforms(key)) === null || _a === void 0 ? void 0 : _a.incoming;
            if (transform) {
                updatedValue = transform(val);
            }
            this._setValue(out, key, this._wrapInModel(updatedValue, key));
        });
        return out;
    }
    _innerExport() {
        const out = this._getDefaultValues();
        this._map(this._innerModel, (val, key) => {
            let outValue = core_1.isModel(val) ? val.export() : val;
            const transform = this._getApplicableTransforms(key);
            if (transform === null || transform === void 0 ? void 0 : transform.outgoing) {
                outValue = transform.outgoing(outValue);
            }
            this._setValue(out, key, outValue);
        });
        return out;
    }
}
exports._KeyedModel = _KeyedModel;
