"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var Lint = require("tslint");
var utils = require("tsutils/typeguard/2.8");
var Ignore = require("./shared/ignore");
var check_node_1 = require("./shared/check-node");
/**
 * This rule checks that the readonly keyword is used in all PropertySignature and
 * IndexerSignature nodes (which are the only places that the readonly keyword can exist).
 */
// tslint:disable-next-line:variable-name
exports.Rule = check_node_1.createCheckNodeRule(Ignore.checkNodeWithIgnore(checkNode), "A readonly modifier is required.");
function checkNode(node, ctx) {
    return checkPropertySignatureAndIndexSignature(node, ctx);
}
function checkPropertySignatureAndIndexSignature(node, ctx) {
    if ((utils.isPropertySignature(node) ||
        utils.isIndexSignatureDeclaration(node) ||
        utils.isPropertyDeclaration(node)) &&
        !(node.modifiers &&
            node.modifiers.filter(function (m) { return m.kind === ts.SyntaxKind.ReadonlyKeyword; })
                .length > 0)) {
        // Check if ignore-prefix applies
        if (Ignore.shouldIgnore(node, ctx.options, ctx.sourceFile)) {
            return { invalidNodes: [] };
        }
        var start = utils.isIndexSignatureDeclaration(node)
            ? node.getStart(ctx.sourceFile)
            : node.name.getStart(ctx.sourceFile);
        return {
            invalidNodes: [
                check_node_1.createInvalidNode(node, [new Lint.Replacement(start, 0, "readonly ")])
            ]
        };
    }
    return { invalidNodes: [] };
}
//# sourceMappingURL=readonlyKeywordRule.js.map