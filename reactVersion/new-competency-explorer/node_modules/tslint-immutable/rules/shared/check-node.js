"use strict";
/**
 * This file has functions that enable walking the nodes
 * and just providing a CheckNodeFunction that returns invalid
 * nodes. It enables a more functional style of programming rules
 * using the CheckNodeFunction as an expression that returns errors.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var Lint = require("tslint");
var options_1 = require("./options");
function createInvalidNode(node, replacements) {
    return { node: node, replacements: replacements };
}
exports.createInvalidNode = createInvalidNode;
function walk(ctx, checkNode, failureString) {
    return ts.forEachChild(ctx.sourceFile, cb);
    function cb(node) {
        // Check the node
        var _a = checkNode(node, ctx), invalidNodes = _a.invalidNodes, skipChildren = _a.skipChildren;
        reportInvalidNodes(invalidNodes, ctx, failureString);
        if (skipChildren) {
            return;
        }
        // Use return because performance hints docs say it optimizes the function using tail-call recursion
        return ts.forEachChild(node, cb);
    }
}
exports.walk = walk;
function walkTyped(ctx, checkTypedNode, checker, failureString) {
    return ts.forEachChild(ctx.sourceFile, cb);
    function cb(node) {
        // Check the node
        var _a = checkTypedNode(node, ctx, checker), invalidNodes = _a.invalidNodes, skipChildren = _a.skipChildren;
        reportInvalidNodes(invalidNodes, ctx, failureString);
        if (skipChildren) {
            return;
        }
        // Use return because performance hints docs say it optimizes the function using tail-call recursion
        return ts.forEachChild(node, cb);
    }
}
exports.walkTyped = walkTyped;
function createCheckNodeRule(checkNode, failureString, 
// tslint:disable-next-line:no-any
parseOptions
// tslint:disable-next-line:no-any
) {
    if (parseOptions === void 0) { parseOptions = options_1.parseOptions; }
    return /** @class */ (function (_super) {
        __extends(Rule, _super);
        function Rule() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Rule.prototype.apply = function (sourceFile) {
            return this.applyWithFunction(sourceFile, function (ctx) {
                return walk(ctx, checkNode, failureString);
            }, parseOptions(this.ruleArguments));
        };
        return Rule;
    }(Lint.Rules.AbstractRule));
}
exports.createCheckNodeRule = createCheckNodeRule;
function createCheckNodeTypedRule(checkTypedNode, failureString, 
// tslint:disable-next-line:no-any
parseOptions
// tslint:disable-next-line:no-any
) {
    if (parseOptions === void 0) { parseOptions = options_1.parseOptions; }
    return /** @class */ (function (_super) {
        __extends(Rule, _super);
        function Rule() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Rule.prototype.applyWithProgram = function (sourceFile, program) {
            return this.applyWithFunction(sourceFile, function (ctx, checker) {
                return walkTyped(ctx, checkTypedNode, checker, failureString);
            }, parseOptions(this.ruleArguments), program.getTypeChecker());
        };
        return Rule;
    }(Lint.Rules.TypedRule));
}
exports.createCheckNodeTypedRule = createCheckNodeTypedRule;
function reportInvalidNodes(invalidNodes, ctx, failureString) {
    invalidNodes.forEach(function (invalidNode) {
        return ctx.addFailureAtNode(invalidNode.node, failureString, invalidNode.replacements);
    });
}
//# sourceMappingURL=check-node.js.map